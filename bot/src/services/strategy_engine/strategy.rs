//! Strategy trait and related types

use serde::{Deserialize, Serialize};

/// Trading signal generated by a strategy
#[derive(Debug, Clone, PartialEq)]
pub enum StrategySignal {
    /// Buy signal
    Buy {
        confidence: f64, // 0.0 to 1.0
        price: f64,
        reason: String,
    },
    /// Sell signal
    Sell {
        confidence: f64, // 0.0 to 1.0
        price: f64,
        reason: String,
    },
    /// Hold (no action)
    Hold,
}

/// Configuration for a strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    /// Strategy type/name (e.g., "RSI", "MACD", "Bollinger")
    pub strategy_type: String,
    /// Strategy parameters (JSON serializable)
    pub parameters: serde_json::Value,
    /// Trading pair (e.g., "BTC/USDT")
    pub pair: String,
    /// Timeframe (e.g., "1m", "5m", "1h")
    pub timeframe: String,
    /// Buy condition string (e.g., "RSI < 30")
    pub buy_condition: String,
    /// Sell condition string (e.g., "RSI > 70")
    pub sell_condition: String,
}

/// OHLC (Open, High, Low, Close) candle data
#[derive(Debug, Clone)]
pub struct Candle {
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
    pub timestamp: i64,
}

/// Strategy trait - all strategies must implement this
pub trait Strategy: Send + Sync + std::fmt::Debug {
    /// Get the name/type of this strategy
    fn name(&self) -> &str;
    
    /// Get the configuration of this strategy
    fn config(&self) -> &StrategyConfig;
    
    /// Process a new candle and generate a signal
    /// Returns Some(signal) if there's a trading signal, None otherwise
    fn process_candle(&mut self, candle: &Candle) -> Option<StrategySignal>;
    
    /// Reset strategy state (e.g., when starting fresh)
    fn reset(&mut self);
    
    /// Get current state/info (for debugging)
    fn get_state_info(&self) -> String;
}

/// Helper to parse buy/sell conditions
pub fn parse_condition(condition: &str, indicator_value: f64) -> bool {
    // Simple parser for conditions like "RSI < 30", "RSI > 70", etc.
    let condition = condition.trim();
    
    // Remove common prefixes like "RSI ", "MACD ", etc.
    let condition = condition.split_whitespace().skip(1).collect::<Vec<_>>().join(" ");
    
    // Parse operators: <, >, <=, >=, ==, !=
    if let Some(pos) = condition.find("<=") {
        let threshold: f64 = condition[pos + 2..].trim().parse().unwrap_or(0.0);
        return indicator_value <= threshold;
    }
    if let Some(pos) = condition.find(">=") {
        let threshold: f64 = condition[pos + 2..].trim().parse().unwrap_or(0.0);
        return indicator_value >= threshold;
    }
    if let Some(pos) = condition.find("<") {
        let threshold: f64 = condition[pos + 1..].trim().parse().unwrap_or(0.0);
        return indicator_value < threshold;
    }
    if let Some(pos) = condition.find(">") {
        let threshold: f64 = condition[pos + 1..].trim().parse().unwrap_or(0.0);
        return indicator_value > threshold;
    }
    if let Some(pos) = condition.find("==") {
        let threshold: f64 = condition[pos + 2..].trim().parse().unwrap_or(0.0);
        return (indicator_value - threshold).abs() < 0.01;
    }
    
    false
}

